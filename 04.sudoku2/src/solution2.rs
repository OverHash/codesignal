use std::collections::HashSet;

#[allow(dead_code)]
fn sudoku2(grid: Vec<Vec<char>>) -> bool {
    let mut seen = HashSet::new();

    for (i, row) in grid.iter().enumerate() {
        for (j, current_val) in row.iter().enumerate() {
            if current_val == &'.' {
                continue;
            }

            if !seen.insert(format!("{} found in row {}", current_val, i))
                || !seen.insert(format!("{} found in column {}", current_val, j))
                || !seen.insert(format!(
                    "{} found in sub-box {}:{}",
                    current_val,
                    i / 3,
                    j / 3
                ))
            {
                return false;
            }
        }
    }

    true
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn handles_valid_solution() {
        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '.', '1', '4', '.', '.', '2', '.'],
                vec!['.', '.', '6', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '1', '.', '.', '.', '.', '.', '.'],
                vec!['.', '6', '7', '.', '.', '.', '.', '.', '9'],
                vec!['.', '.', '.', '.', '.', '.', '8', '1', '.'],
                vec!['.', '3', '.', '.', '.', '.', '.', '.', '6'],
                vec!['.', '.', '.', '.', '.', '7', '.', '.', '.'],
                vec!['.', '.', '.', '5', '.', '.', '.', '7', '.']
            ]),
            true
        );

        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '2'],
                vec!['.', '.', '.', '.', '.', '.', '6', '.', '.'],
                vec!['.', '.', '1', '4', '.', '.', '8', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '3', '.', '.', '.', '.'],
                vec!['5', '.', '8', '6', '.', '.', '.', '.', '.'],
                vec!['.', '9', '.', '.', '.', '.', '4', '.', '.'],
                vec!['.', '.', '.', '.', '5', '.', '.', '.', '.']
            ]),
            true
        );

        assert_eq!(
            sudoku2(vec![
                vec!['.', '9', '.', '.', '4', '.', '.', '.', '.'],
                vec!['1', '.', '.', '.', '.', '.', '6', '.', '.'],
                vec!['.', '.', '3', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '7', '.', '.', '.', '.', '.'],
                vec!['3', '.', '.', '.', '5', '.', '.', '.', '.'],
                vec!['.', '.', '7', '.', '.', '4', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '7', '.', '.', '.', '.']
            ]),
            true
        );
    }

    #[test]
    fn handles_invalid_sub_grid() {
        // invalid because of sub-grid 1 having '4's
        assert_eq!(
            sudoku2(vec![
                vec!['.', '4', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '4', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '1', '.', '.', '7', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '3', '.', '.', '.', '6', '.'],
                vec!['.', '.', '.', '.', '.', '6', '.', '9', '.'],
                vec!['.', '.', '.', '.', '1', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '2', '.', '.'],
                vec!['.', '.', '.', '8', '.', '.', '.', '.', '.']
            ]),
            false
        );
    }

    #[test]
    fn handles_invalid_row() {
        // invalid because of row 5 having two '5's
        assert_eq!(
            sudoku2(vec![
                vec!['7', '.', '.', '.', '4', '.', '.', '.', '.'],
                vec!['.', '.', '.', '8', '6', '5', '.', '.', '.'],
                vec!['.', '1', '.', '2', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '9', '.', '.', '.'],
                vec!['.', '.', '.', '.', '5', '.', '5', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '2', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.']
            ]),
            false
        );
    }

    #[test]
    fn handles_invalid_solution_column() {
        // invalid because of the '1's on column 2
        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '.', '.', '2', '.', '.', '9', '.'],
                vec!['.', '.', '.', '.', '6', '.', '.', '.', '.'],
                vec!['7', '1', '.', '.', '7', '5', '.', '.', '.'],
                vec!['.', '7', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '8', '3', '.', '.', '.'],
                vec!['.', '.', '8', '.', '.', '7', '.', '6', '.'],
                vec!['.', '.', '.', '.', '.', '2', '.', '.', '.'],
                vec!['.', '1', '.', '2', '.', '.', '.', '.', '.'],
                vec!['.', '2', '.', '.', '3', '.', '.', '.', '.']
            ]),
            false
        );

        // invalid because of the '5's on column 4
        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '4', '.', '.', '.', '6', '3', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['5', '.', '.', '.', '.', '.', '.', '9', '.'],
                vec!['.', '.', '.', '5', '6', '.', '.', '.', '.'],
                vec!['4', '.', '3', '.', '.', '.', '.', '.', '1'],
                vec!['.', '.', '.', '7', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '5', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.']
            ]),
            false
        );
    }
}
