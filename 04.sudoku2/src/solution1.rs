use std::collections::HashSet;

#[allow(dead_code)]
fn sudoku2(grid: Vec<Vec<char>>) -> bool {
    // validate each 3x3 grid is correct
    for sub_grid_x in 0..3 {
        for sub_grid_y in 0..3 {
            let mut seen = HashSet::new();

            for n in 0..9 {
                let grid_index_row = sub_grid_y * 3 + (n / 3);
                let grid_index_column = sub_grid_x * 3 + (n % 3);
                let elem = grid[grid_index_row][grid_index_column];

                if elem == '.' {
                    continue;
                }

                if seen.contains(&elem) {
                    return false;
                }

                seen.insert(elem);
            }
        }
    }

    // validate no elements in same row
    for row in &grid {
        let mut seen = HashSet::new();

        for elem in row {
            if elem == &'.' {
                continue;
            }

            if seen.contains(&elem) {
                return false;
            }

            seen.insert(elem);
        }
    }

    // validate no elements in same column
    for i in 0..9 {
        let mut seen = HashSet::new();

        for row in &grid {
            if row[i] == '.' {
                continue;
            }

            if seen.contains(&row[i]) {
                return false;
            }

            seen.insert(&row[i]);
        }
    }

    true
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn handles_valid_solution() {
        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '.', '1', '4', '.', '.', '2', '.'],
                vec!['.', '.', '6', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '1', '.', '.', '.', '.', '.', '.'],
                vec!['.', '6', '7', '.', '.', '.', '.', '.', '9'],
                vec!['.', '.', '.', '.', '.', '.', '8', '1', '.'],
                vec!['.', '3', '.', '.', '.', '.', '.', '.', '6'],
                vec!['.', '.', '.', '.', '.', '7', '.', '.', '.'],
                vec!['.', '.', '.', '5', '.', '.', '.', '7', '.']
            ]),
            true
        );

        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '2'],
                vec!['.', '.', '.', '.', '.', '.', '6', '.', '.'],
                vec!['.', '.', '1', '4', '.', '.', '8', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '3', '.', '.', '.', '.'],
                vec!['5', '.', '8', '6', '.', '.', '.', '.', '.'],
                vec!['.', '9', '.', '.', '.', '.', '4', '.', '.'],
                vec!['.', '.', '.', '.', '5', '.', '.', '.', '.']
            ]),
            true
        );

        assert_eq!(
            sudoku2(vec![
                vec!['.', '9', '.', '.', '4', '.', '.', '.', '.'],
                vec!['1', '.', '.', '.', '.', '.', '6', '.', '.'],
                vec!['.', '.', '3', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '7', '.', '.', '.', '.', '.'],
                vec!['3', '.', '.', '.', '5', '.', '.', '.', '.'],
                vec!['.', '.', '7', '.', '.', '4', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '7', '.', '.', '.', '.']
            ]),
            true
        );
    }

    #[test]
    fn handles_invalid_sub_grid() {
        // invalid because of sub-grid 1 having '4's
        assert_eq!(
            sudoku2(vec![
                vec!['.', '4', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '4', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '1', '.', '.', '7', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '3', '.', '.', '.', '6', '.'],
                vec!['.', '.', '.', '.', '.', '6', '.', '9', '.'],
                vec!['.', '.', '.', '.', '1', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '2', '.', '.'],
                vec!['.', '.', '.', '8', '.', '.', '.', '.', '.']
            ]),
            false
        );
    }

    #[test]
    fn handles_invalid_row() {
        // invalid because of row 5 having two '5's
        assert_eq!(
            sudoku2(vec![
                vec!['7', '.', '.', '.', '4', '.', '.', '.', '.'],
                vec!['.', '.', '.', '8', '6', '5', '.', '.', '.'],
                vec!['.', '1', '.', '2', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '9', '.', '.', '.'],
                vec!['.', '.', '.', '.', '5', '.', '5', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '2', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.']
            ]),
            false
        );
    }

    #[test]
    fn handles_invalid_solution_column() {
        // invalid because of the '1's on column 2
        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '.', '.', '2', '.', '.', '9', '.'],
                vec!['.', '.', '.', '.', '6', '.', '.', '.', '.'],
                vec!['7', '1', '.', '.', '7', '5', '.', '.', '.'],
                vec!['.', '7', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '8', '3', '.', '.', '.'],
                vec!['.', '.', '8', '.', '.', '7', '.', '6', '.'],
                vec!['.', '.', '.', '.', '.', '2', '.', '.', '.'],
                vec!['.', '1', '.', '2', '.', '.', '.', '.', '.'],
                vec!['.', '2', '.', '.', '3', '.', '.', '.', '.']
            ]),
            false
        );

        // invalid because of the '5's on column 4
        assert_eq!(
            sudoku2(vec![
                vec!['.', '.', '4', '.', '.', '.', '6', '3', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['5', '.', '.', '.', '.', '.', '.', '9', '.'],
                vec!['.', '.', '.', '5', '6', '.', '.', '.', '.'],
                vec!['4', '.', '3', '.', '.', '.', '.', '.', '1'],
                vec!['.', '.', '.', '7', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '5', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.'],
                vec!['.', '.', '.', '.', '.', '.', '.', '.', '.']
            ]),
            false
        );
    }
}
